---
interface Props {
  pages: {
    [key: string]: string;
  };
}

const { pages } = Astro.props;
const pageKeys = Object.keys(pages);
---

<div class="flex h-screen">
  <!-- Left sidebar -->
  <div class="w-2xs bg-gray-900 text-white p-8 menu-container">
    <div class="space-y-0">
      {
        pageKeys.map((key, index) => (
          <button
            class="menu-item w-full text-left p-4 hover:bg-gray-700 transition-colors text-3xl font-light"
            data-page={key}
            class:list={[{ active: index === 0 }]}
          >
            {key.charAt(0).toUpperCase() + key.slice(1)}
          </button>
        ))
      }
    </div>
  </div>

  <!-- Right content area -->
  <div class="flex-1 bg-white p-8 overflow-auto">
    <div id="content"></div>
  </div>
</div>

<script define:vars={{ pages }}>
  const menuItems = document.querySelectorAll(".menu-item");
  const contentDiv = document.getElementById("content");
  const menuContainer = document.querySelector(".menu-container");
  let selectedPage = Object.keys(pages)[0];

  // Improved Observer Logic
  let observer;
  function initScrollAnimations() {
    if (observer) observer.disconnect();

    const elements = document.querySelectorAll(
      ".portfolio-image-left, .portfolio-image-right, .portfolio-text, .portfolio-section",
    );

    if (elements.length === 0) {
      console.log("No elements found for animation.");
      return;
    }

    console.log("Setting up observer for:", elements.length, "elements");

    observer = new IntersectionObserver(
      (entries) => {
        entries.forEach((entry) => {
          if (entry.isIntersecting) {
            const el = entry.target;
            console.log("Element intersecting:", el);
            if (el.classList.contains("portfolio-image-left")) {
              el.classList.add("animate-slide-in-left");
            } else if (el.classList.contains("portfolio-image-right")) {
              el.classList.add("animate-slide-in-right");
            } else if (el.classList.contains("portfolio-text")) {
              el.classList.add("animate-fade-in-up");
            } else if (el.classList.contains("portfolio-section")) {
              el.classList.add("animate-fade-in");
            }
            observer.unobserve(el);
          }
        });
      },
      {
        threshold: 0.1, // Slightly higher threshold
        rootMargin: "100px 0px 0px 0px", // Larger root margin
      },
    );

    elements.forEach((el) => observer.observe(el));
  }

  // Helper to swap content and re-trigger animations
  function updateContent(pageKey) {
    contentDiv.innerHTML = pages[pageKey];
    console.log("Content inserted:", contentDiv.innerHTML);
    // Wait for the next tick to ensure DOM is updated
    setTimeout(() => {
      initScrollAnimations();
    }, 0);
  }

  // Click to select
  menuItems.forEach((item) => {
    item.addEventListener("click", () => {
      menuItems.forEach((m) => m.classList.remove("active"));
      item.classList.add("active");
      selectedPage = item.dataset.page;
      updateContent(selectedPage);
    });
  });

  // Hover to preview
  menuItems.forEach((item) => {
    item.addEventListener("mouseenter", () => {
      const page = item.dataset.page;
      contentDiv.classList.add("fade-out");
      setTimeout(() => {
        updateContent(page);
        contentDiv.classList.remove("fade-out");
      }, 150);
    });
  });

  // Only revert when leaving the entire menu
  menuContainer.addEventListener("mouseleave", () => {
    contentDiv.classList.add("fade-out");
    setTimeout(() => {
      updateContent(selectedPage);
      contentDiv.classList.remove("fade-out");
    }, 150);
  });

  // Show default page
  updateContent(selectedPage);
</script>

<style>
  /* Non-animation styles (layout, menu, etc.) */
  .menu-item {
    transition: background-color 0.2s;
  }

  .menu-item.active {
    background-color: rgb(55, 65, 81);
    border-left: 4px solid rgb(59, 130, 246);
  }

  #content {
    transition: opacity 0.15s ease-out;
  }

  #content.fade-out {
    opacity: 0;
  }

  /* Initial hidden state */
  .portfolio-image-left,
  .portfolio-image-right,
  .portfolio-text,
  .portfolio-section {
    opacity: 0;
    min-height: 1px;
  }

  /* Animation delays for staggered effects */
  .portfolio-image:nth-child(1) { animation-delay: 0s; }
  .portfolio-image:nth-child(2) { animation-delay: 0.15s; }
  .portfolio-image:nth-child(3) { animation-delay: 0.3s; }
  .portfolio-image:nth-child(4) { animation-delay: 0.45s; }
  .portfolio-image:nth-child(5) { animation-delay: 0.6s; }
</style>
